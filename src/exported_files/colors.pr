import 'package:flutter/material.dart';

import '../color/swatch.dart';

/// 앱 컬러는 브랜드, 시멘틱 두 가지의 체계를 가집니다.
/// [BrandColors]는 앱의 정체성을 나타내는 색입니다.
///
/// [SemanticColors]는 앱 내에서 목적에 맞게 사용되는 컬러입니다.
class AppColors {
  const AppColors._();

  static const Color white = Color(0xffffffff);

  static const Color black = Color(0xff000000);
{[ let brand = ds.currentBrand() /]}
{[ let brandColors = [] /]}
{[ let semanticColors = [] /]}
{[ const colorTokensTree = ds.tokenGroupTreeByType("Color", brand.id) /]}
{[ const mainGroups = colorTokensTree.subgroups /]}
{[ for mainGroup in mainGroups ]}
  {[ const groupName = mainGroup.name.camelcased(false) /]}
  {[ if (groupName === "brand") ]} {* Brand Colors *}
  {[ set brandColors = mainGroup.subgroups /]}
  static const {{ mainGroup.name.camelcased(true) }}Colors {{ groupName }} = {{ mainGroup.name.camelcased(true) }}Colors._();
  {[ elseif (groupName === "semantic") ]} {* Semantic Colors *}
  {[ set semanticColors = mainGroup.subgroups /]}
  static const {{ mainGroup.name.camelcased(true) }}Colors {{ groupName }} = {{ mainGroup.name.camelcased(true) }}Colors._();
  {[/]}
  {[/]}
{[/]}
}

/// BrandColors
/// 브랜드 컬러는 앱의 아이덴티티를 좌우하는 중요한 색상입니다.
///
/// [primary]는 서비스 전반의 메인 컬러 요소로 활용되는 색상입니다.
///
/// 추가적인 컬러의 정의가 필요한 경우
/// 시멘틱 컬러에 정의해서 사용합니다.
class BrandColors {
  const BrandColors._();
  {[ for brandColor in brandColors ]}
  {[ const colors = ds.tokensByGroupId(brandColor.id) /]}
  {[ const primaryColor = findInObjects(colors, "name", "50") /]}
  const BalanceColor {{ brandColor.name.camelcased(false) }} = BalanceColor(
    {{ convertHexColor(primaryColor.value) }}, {* 6th of entries is primary color *}
    <int, Color>{
      {[ for color in colors ]}
        {{ color.name }}: Color({{ convertHexColor(color.value) }}),
      {[/]}
    },
  );
  {[/]}
}

/// SemanticColors
/// 시멘틱 컬러는 사용 목적에 따라 정의합니다.
/// 특별한 목적이 없는 컬러셋의 확장은 지양합니다.
///
/// 시멘틱 컬러는 색 자체가 정보로 받아들여지기 때문에
/// 변경시 각별히 유의해야 합니다.
/// https://spectrum.adobe.com/page/color/#Semantic-colors
///
class SemanticColors implements AppColors {
  const SemanticColors._();

  {[ for semanticColor in semanticColors ]}
  const {{ semanticColor.name.camelcased(true) }}Colors {{ semanticColor.name.camelcased(false) }} = {{ semanticColor.name.camelcased(true) }}Colors._();
  {[/]}
}

{[ for semanticColor in semanticColors ]}
class {{ semanticColor.name.camelcased(true) }}Colors implements SemanticColors {
  const {{ semanticColor.name.camelcased(true) }}Colors._();

{* check is category *}
{[ const currentColors = ds.tokensByGroupId(semanticColor.id) /]}
{[ if (currentColors.count() > 0) ]}
{[ for currentColor in currentColors ]}
  const Color {{ currentColor.name.camelcased(false) }} = Color({{ convertHexColor(currentColor.value) }});
{[/]}
{[ else ]}
{[ if (semanticColor.subgroups.count() > 0) ]}
{[ for subgroup in semanticColor.subgroups ]}
  {[ const colors = ds.tokensByGroupId(subgroup.id) /]}
  {[ const primaryColor = findInObjects(colors, "name", "Basic") /]}
  const SemanticColor {{ subgroup.name.camelcased(false) }} = SemanticColor(
    {{ convertHexColor(primaryColor.value) }},
    <String, Color>{
      {[ for color in colors ]}
        '{{ color.name.camelcased(false) }}': Color({{ convertHexColor(color.value) }}),
      {[/]}
    },
  );
{[/]}
{[/]}
{[/]}
}
{[/]}

class SemanticColor extends ColorSwatch<String> {
  /// Primary is Basic
  const SemanticColor(int primary, Map<String, Color> swatch)
      : super(primary, swatch);

  Color get basic => this['basic']!;

  Color get light => this['light']!;

  Color? get text => this['text'];
}
